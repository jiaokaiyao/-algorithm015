学习笔记

# 本周知识点

## 高级动态规划

### 动态规划关键点

- 和递归和分治没有本质上的区别，关键看是否存在最优子结构

  1. 区别：动态规划有最优子结构，中途淘汰次优解
  2. 共性：找到重复子问题

  

高级动态规划复杂度来源

- 状态拥有更多维
- 状态方程更加复杂

常见DP题目和状态转移方程

1. 爬楼梯问题 

   ```
   dp[i] = dp[i - 1] + dp[i-2]
   ```

   

2. 不同路径问题

   ```
   dp[i][j] = dp[i -1][j] + dp[i][j - 1]
   ```

   

3. 打家劫舍

   ```
   dp[i]状态的定义： max $ of robbing A[0 -> i]
   dp[i] = max(dp[i - 2] + nums[i], dp[i - 1])
   
   dp[i][0]状态定义：max $ of robbing A[0 -> i] 且没偷 nums[i]
   dp[i][1]状态定义：max $ of robbing A[0 -> i] 且偷了 nums[i]
   
   
   dp[i][0] = max(dp[i - 1][0], dp[i - 1][1]);
   dp[i][1] = dp[i - 1][0] + nums[i];
   ```

   

4. 最小路径和

   ```
   dp[i][j]状态的定义： minPath(A[1 -> i][1 -> j])
   dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + A[i][j]
   ```

   

5. 股票买卖

   ```
   • i 为天数
   • k 为最多交易次数
   • [0,1] 为是否持有股票
   总状态数： n * K * 2 种状态
   dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i])
                  max( 选择 rest , 选择 sell )
   解释：今天我没有持有股票，有两种可能：
   - 我昨天就没有持有，然后今天选择 rest，所以我今天还是没有持有；
   - 我昨天持有股票，但是今天我 sell 了，所以我今天没有持有股票了。
   dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i])
                 max( 选择 rest , 选择 buy )
   解释：今天我持有着股票，有两种可能：
   - 我昨天就持有着股票，然后今天选择 rest，所以我今天还持有着股票；
   - 我昨天本没有持有，但今天我选择 buy，所以今天我就持有股票了。
   
   初始状态：
   dp[-1][k][0] = dp[i][0][0] = 0
   dp[-1][k][1] = dp[i][0][1] = -infinity
   状态转移方程：
   dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i])
   dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i])
   ```

   

6. 

7. 

8. 

9. 

   ```
   
   ```



## 字符串

Java语言中，字符串不可改变的

```java
String A = "this";
String B = "this";
A == B; // false 比较的是地址
A.equals(B); // true 比较的是值

```

### 高级字符串算法

#### 朴素算法

主串M的第一个字符开始分别与子串从开头进行比较，当发现不匹配时，主串回到这一轮开始的下一个字符，子串从头开始比较。直到子串所有的字符都匹配，返回所在主串中的下标。

#### Rabin-Karp算法

1. 假设子串的长度为M(pat), 目标字符串的长度为N(txt)
2. 计算子串的hash值hash_pat
3. 计算目标字符串txt中每个长度为M的子串的hash值（共需要计算N-M +1次）
4. 比较hash值，如果hash值不相同，字符串必然不匹配，如果hash值相同，还需要朴素算法再次计算

#### KMP算法

思想：当子串与目标字符串匹配时，其实已经知道了那些已经匹配成功的一部分字符（子串与目标字符串），也就是说要设法利用这个已知信息，不要把”搜索位置“移回已经比较过的位置，继续把它向后移，这样就提高了效率

- 找出子串每个字符的前缀

- 然后计算每个前缀子串的公共前后缀得到前缀表【prefix table】

  a b a b c

  ============

  prefix table

  -1      // 前面补 -1

  0        a

  0        a b

  1        a b a

  2       a b a b

  ​          ~~a b a b c~~  // 不要  因为数组下标从0开始

  所以前缀表为 [-1,0,0,1,2]

  - 根据前缀表去匹配

    每次匹配到不匹配的位置，将子串的前缀表位置移动到当前目标串中不匹配的位置，然后继续从当前位置开始往后匹配，直到找到结果或目标字符串已经被匹配完毕

  

### 